typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
typedef uint32_t size_t;

typedef struct {
	uint8_t ident[16];
	uint16_t type;
	uint16_t machine;
	uint32_t version;
	uint64_t entry;
	uint64_t phoff;
	uint64_t shoff;
	uint32_t flags;
	uint16_t ehsize;
	uint16_t phentsize;
	uint16_t phnum;
	uint16_t shentsize;
	uint16_t shnum;
	uint16_t shstrndx;
} __attribute__((packed)) elf_header;

typedef struct {
	uint32_t type;
	uint32_t flags;
	uint64_t offset;
	uint64_t vaddr;
	uint64_t paddr;
	uint64_t filesz;
	uint64_t memsz;
	uint64_t align;
} __attribute__((packed)) elf_program_header;

typedef struct {
	uint16_t size;
	uint64_t *gdt;
} __attribute__((packed)) gdtr;

__attribute__((section(".bootloader162var")))
uint64_t gdt[3] = {
	0,
  	0x00CF9A000000FFFF,
  	0x00CF92000000FFFF,
};

__attribute__((section(".bootloader162var")))
gdtr gdtr_val = {
	sizeof(gdt) - 1,
	gdt,
};

__attribute__((section(".bootloader162")))
void *memcpy(void *restrict dest, const void *restrict src, size_t n) {
    uint8_t *restrict pdest = (uint8_t *restrict)dest;
    const uint8_t *restrict psrc = (const uint8_t *restrict)src;

    for (size_t i = 0; i < n; i++) {
        pdest[i] = psrc[i];
    }

    return dest;
}

__attribute__((section(".bootloader162")))
void *memset(void *s, int c, size_t n) {
    uint8_t *p = (uint8_t *)s;

    for (size_t i = 0; i < n; i++) {
        p[i] = (uint8_t)c;
    }

    return s;
}

__attribute__((section(".bootloader162")))
void *memmove(void *dest, const void *src, size_t n) {
    uint8_t *pdest = (uint8_t *)dest;
    const uint8_t *psrc = (const uint8_t *)src;

    if (src > dest) {
        for (size_t i = 0; i < n; i++) {
            pdest[i] = psrc[i];
        }
    } else if (src < dest) {
        for (size_t i = n; i > 0; i--) {
            pdest[i-1] = psrc[i-1];
        }
    }

    return dest;
}

__attribute__((section(".bootloader162")))
int memcmp(const void *s1, const void *s2, size_t n) {
    const uint8_t *p1 = (const uint8_t *)s1;
    const uint8_t *p2 = (const uint8_t *)s2;

    for (size_t i = 0; i < n; i++) {
        if (p1[i] != p2[i]) {
            return p1[i] < p2[i] ? -1 : 1;
        }
    }

    return 0;
}

__attribute__((section(".bootloader162"), noreturn, naked))
void hcf(void) {
    for (;;) {
        asm ("hlt");
    }
}

typedef struct {
	uint8_t size;
	uint8_t zero;
	uint16_t num_of_sectors;
	uint16_t dest_offset;
	uint16_t dest_segment;
	uint32_t lower_lba;
	uint32_t higher_lba;
} __attribute__((packed)) dap;


__attribute__((section(".bootloader162var"), aligned(16)))
dap rfd_dap = {0};

__attribute__((section(".bootloader162var")))
uint32_t load_addr_of_ph[10];

__attribute__((section(".bootloader162")))
void read_from_disk(uint16_t disk, uint16_t num_of_sectors, uint16_t dest_offset, uint16_t dest_segment, uint64_t lba) {
	rfd_dap.size = 16;
	rfd_dap.num_of_sectors = num_of_sectors;
	rfd_dap.dest_offset = dest_offset;
	rfd_dap.dest_segment = dest_segment;
	rfd_dap.lower_lba = lba & 0xffffffff;
	rfd_dap.higher_lba = (lba >> 32) & 0xffffffff;

	asm volatile("mov %0, %%si" : : "r"((uint16_t)(uint32_t)&rfd_dap) : "si");
	asm volatile("mov %0, %%dl" : : "r"((uint8_t)disk) : "dl");
	asm volatile("mov $0x42, %%ah" : : : "ah");
	asm volatile("int $0x13");
	asm volatile("jc hcf");
}

__attribute__((section(".bootloader162"), noreturn))
void bootloader_16_2(void) {
	/*
	eax contains memory_map_entries
	ebx contains video_mode_info
	ecx contains size_of_bootloader
	edx contains boot_disk
	*/
	uint32_t memory_map;
	uint32_t video_mode_info;
	uint32_t size_of_bootloader;
	uint32_t boot_disk;
	asm volatile("mov %%eax, %0" : "=m"(memory_map) : : );
	asm volatile("mov %%ebx, %0" : "=m"(video_mode_info) : : );
	asm volatile("mov %%ecx, %0" : "=m"(size_of_bootloader) : : );
	asm volatile("mov %%edx, %0" : "=m"(boot_disk) : : ); 
	/*
	crash if sizes dont match, it makes no sense to continue
	*/
  	if (sizeof(uint16_t) != 2 && sizeof(uint32_t) != 4 && sizeof(uint64_t) != 8) {
  		asm volatile("int $0xff");
  	}

  	/*
	the lba of elf on boot disk, it is aligned to 512 after the bootloader
	first sector is boot sector, then bootloader and finally the elf,
	all aligned to 512
  	*/
  	uint64_t lba_of_elf = (512 + ((size_of_bootloader + 511) & (~511))) / 512;  
  	/*
  	we read the elf header into ram at 0x7c00
	we just override the boot sector, since we dont need it anymore
  	*/
  	read_from_disk(boot_disk, 1, 0x7c00, 0, lba_of_elf);
  	elf_header *elf = (elf_header*)0x7c00;
  	/*
	next we need to load the array of program headers into memory
	we will place this after the bootloader, but aligned to 512
  	*/
  	uint16_t ph_addr = 0x7c00 + (uint16_t)lba_of_elf * 512;
  	/*
	lba of ph is the offset on the disk aligned down
  	*/
  	uint64_t lba_of_ph = lba_of_elf + elf->phoff / 512;
  	/*
	lastly we need the length, 
	first we align to 512 and then divide by 512
	we add one if we aligned down
	i dont know if this is needed, but it shouldnt hurt
  	*/
  	uint16_t num_of_sectors_ph = ((elf->phnum * elf->phentsize + 511) & (~511)) / 512 + 1;
  	/*
	now we can read the program headers into memory
	the start is the remainder of the offset divided by 512
	since we divided down
	NOTE: we could also create a global list with say 10 entries in which we load this
  	*/
  	read_from_disk(boot_disk, num_of_sectors_ph, ph_addr, 0, lba_of_ph);
  	elf_program_header *ph = (elf_program_header*)((uint32_t)ph_addr + ((uint32_t)elf->phoff & 512));

  	uint8_t load = 0;
  	uint16_t load_segment = 0x7000;
  	for (int i = 0; i < elf->phnum; i++) {
  		if (ph[i].type == 1) {
  			/*
			do something similar to loading the program headers above
			for reading the programs from the disk
			*/
  			uint64_t lba_of_ph_ent = lba_of_elf + ph[i].offset / 512;
  			uint16_t num_of_sectors_ph_ent = ((ph[i].filesz + 511) & (~511)) / 512 + 1;
  			read_from_disk(boot_disk, num_of_sectors_ph_ent, 0, load_segment, lba_of_ph_ent);
  			/*
  			we cant load more than 10 segments, can be increased quite easily by increasing
  			the size of global load_addr_of_ph array
			*/
  			if (load > 10) {
  				hcf();
  			}
  			/*
			adjust the variables for the next loop
			and store the address at which we just loaded the new segment
			so we can copy it later
			the 20 bit linear address is calculated be shifting the 
			segment left 4 times and adding the offset
  			*/
  			load_addr_of_ph[load] = (load_segment << 4) + (ph[i].offset & 512);
  			load++;
  			load_segment += num_of_sectors_ph * 16;
  		}
  	} 

  	/*
  	enter protected mode
  	*/

  	asm volatile("lgdt %0" : : "m"(gdtr_val) : "memory");
  	asm volatile("mov %cr0, %eax");
  	asm volatile("or $1, %al");
  	asm volatile("mov %eax, %cr0");

  	/*
	jump to protected mode code
  	*/
  	asm volatile("ljmp $0x8, $bootloader_32");

  	hcf();
}