typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
typedef uint32_t size_t;

typedef struct {
	uint8_t ident[16];
	uint16_t type;
	uint16_t machine;
	uint32_t version;
	uint64_t entry;
	uint64_t phoff;
	uint64_t shoff;
	uint32_t flags;
	uint16_t ehsize;
	uint16_t phentsize;
	uint16_t phnum;
	uint16_t shentsize;
	uint16_t shnum;
	uint16_t shstrndx;
} __attribute__((packed)) elf_header;

typedef struct {
	uint32_t type;
	uint32_t flags;
	uint64_t offset;
	uint64_t vaddr;
	uint64_t paddr;
	uint64_t filesz;
	uint64_t memsz;
	uint64_t align;
} __attribute__((packed)) elf_program_header;

// https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/15_System_Address_Map_Interfaces/int-15h-e820h---query-system-address-map.html
typedef struct {
	uint64_t addr;
	uint64_t length;
	uint32_t type;
	uint32_t acpi;
} __attribute__((packed)) memory_map_ent;

typedef struct {
	uint16_t attributes;
	uint8_t window_a;
	uint8_t window_b;
	uint16_t granularity;
	uint16_t window_size;
	uint16_t segment_a;
	uint16_t segment_b;
	uint32_t win_func_ptr;
	uint16_t pitch;
	uint16_t width;
	uint16_t height;
	uint8_t w_char;
	uint8_t y_char;
	uint8_t planes;
	uint8_t bpp;
	uint8_t banks;
	uint8_t memory_model;
	uint8_t bank_size;
	uint8_t image_pages;
	uint8_t reserved0;

	uint8_t red_mask;
	uint8_t red_position;
	uint8_t green_mask;
	uint8_t green_position;
	uint8_t blue_mask;
	uint8_t blue_position;
	uint8_t reserved_mask;
	uint8_t reserved_position;
	uint8_t direct_color_attributes;

	uint32_t phys_address;
	uint32_t off_screen_mem_off;
	uint16_t off_screen_mem_size;
	uint8_t reserved1[206];
} __attribute__ ((packed)) video_mode_info;

typedef struct {
	uint32_t number_of_ents;
	memory_map_ent memory_map[0x1000];
} __attribute__((packed)) memory_map;

__attribute__((section(".bootloader32")))
void* memset(void* bufptr, int value, size_t size) {
	unsigned char* buf = (unsigned char*) bufptr;
	for (size_t i = 0; i < size; i++)
		buf[i] = (unsigned char) value;
	return bufptr;
}

typedef struct {
	uint16_t size;
	uint64_t *gdt;
} __attribute__((packed)) gdtr;

__attribute__((section(".bootloader32var")))
static uint64_t gdt[3] = {
	0,
  	0x00AF9A000000FFFF,
  	0x00AF92000000FFFF,
};

__attribute__((section(".bootloader32var")))
gdtr gdtr_val = {
	sizeof(gdt) - 1,
	gdt,
};

__attribute__((section(".bootloader32var"), aligned(16)))
uint8_t kernel_stack[0x1000] = {};

extern video_mode_info _vbe_mode_info;
extern void _size_of_bootloader;
extern uint32_t load_addr_of_ph[20];
extern elf_program_header *ph;
extern memory_map _memory_map_entries;

__attribute__((section(".bootloader32"), noreturn))
void bootloader_32(void) {
	/*
	readjust the segment registers
	*/
	asm volatile("mov $0x10, %eax");
	asm volatile("mov %eax, %ds");
	asm volatile("mov %eax, %es");
	asm volatile("mov %eax, %fs");
	asm volatile("mov %eax, %gs");
	asm volatile("mov %eax, %ss");

	/*
	copy the laodable programs
	*/
	elf_header *elf = (elf_header*)0x7c00;
	uint16_t load = 0;
	for (int i = 0; i < elf->phnum; i++) {
		if (ph[i].type == 1) {
			volatile uint8_t *dest = (uint8_t*)(uint32_t)(ph[i].vaddr - 0xffffffff80000000 + 0x200000);
			volatile uint8_t *src = (uint8_t*)(load_addr_of_ph[load++]);
			for (uint64_t j = 0; j < ph[i].filesz; j++) {
				dest[j] = src[j];
			} 
		}
	}

	/*
	create the page tables
	we identity map the first gb of addresses so the bootloader works
	we also map 2gb of physical memory at offset 2mb to the last 2gb of 64 bit
	address space for the kernel
	*/

	uint64_t *pml4 = (uint64_t*)0x100000;
	uint64_t *pdpt_kernel = pml4 + 512;
	uint64_t *pd_kernel = pdpt_kernel + 512;
	uint64_t *pdpt_high = pd_kernel + 1024;
	uint64_t *pdpt_low = pdpt_high + 512;
	uint64_t *pd_low = pdpt_low + 512;

	memset((void*)pml4, 0, (uint64_t)(uint32_t)(pd_low + 512) - (uint64_t)(uint32_t)pml4);

	/*
	map the memory at offset 2mb to the last two gb of address space
	*/
	pml4[511] = (uint64_t)(uint32_t)pdpt_kernel | 0x3;
	pdpt_kernel[510] = (uint64_t)(uint32_t)pd_kernel | 0x3;
	pdpt_kernel[511] = (uint64_t)(uint32_t)&pd_kernel[512] | 0x3;
	uint64_t phys_kernel = 0x200000;
	for (int i = 0; i < 1024; i++) {
		pd_kernel[i] = phys_kernel | 0x83;
		phys_kernel += 0x200000;
	}
	/*
	map the first gigabyte as identity map and to start of higher half
	*/
	pml4[0] = (uint64_t)(uint32_t)pdpt_low | 0x3;
	uint64_t addr = 0;
	// this maps the first 25gb of physical memory, 
	// into higher half and identity maps the first gb
	// which should be enough for the kernel
	// to start up at least
	for (uint32_t i = 0; i < 250; i++) {
		if (i == 0) {
			pdpt_low[i] = (uint64_t)(uint32_t)&pd_low[i * 512] | 0x3;
		}
		pdpt_high[i] = (uint64_t)(uint32_t)&pd_low[i * 512] | 0x3;
		for (int j = 0; j < 512; j++) {
			pd_low[i * 512 + j] =  addr | 0x83;
			addr += 0x200000;
		}
	}
	pml4[256] = (uint64_t)(uint32_t)pdpt_high | 0x3;

	// check if all memory is mapped with 250 gb
	// by calculating the highest address in address space
	uint64_t highest = 0;
	for (uint32_t i = 0; i < _memory_map_entries.number_of_ents; i++) {
		if (_memory_map_entries.memory_map[i].type == 1) {
			if (_memory_map_entries.memory_map[i].addr == _vbe_mode_info.phys_address) {
				_memory_map_entries.memory_map[i].length = 0;
			}
			uint64_t comp = _memory_map_entries.memory_map[i].addr + _memory_map_entries.memory_map[i].length;
			if (comp > highest) highest = comp;
		}
	}
	// We just halt for now
	// should never happen on qemu, maybe with real pcs it is more likely		
	if (highest > ((uint64_t)0x40000000 * 250)) {
		asm volatile("hlt");
	}

	/*
	write pml4 into cr3
	*/
	asm volatile("mov %0, %%eax" : : "r"(pml4) : "eax");
	asm volatile("mov %eax, %cr3");

	/*
	enable pae
	*/
	asm volatile("mov %cr4, %eax");
	asm volatile("or $32, %eax");
	asm volatile("mov %eax, %cr4");

	/*
	switch to compatibility mode
	*/
	asm volatile("mov $0xc0000080, %ecx");
	asm volatile("rdmsr");
	asm volatile("or $256, %eax");
	asm volatile("wrmsr");

	/*
	enable paging
	*/
	asm volatile("mov %cr0, %eax");
	asm volatile("or $0x80000000, %eax");
	asm volatile("mov %eax, %cr0");

	/*
	enter long mode
	*/
	asm volatile("lgdt %0" : : "m"(gdtr_val) : "memory");
	asm volatile("ljmp $0x8, $_jump_to_kernel");

	for (;;) {
		asm volatile("hlt");
	}
	__builtin_unreachable();
}
